header

    #initialise grid
    int[][] initialiseGrid(int width, int height) is
        int[][] grid = call initIntArray2D(0, width, height);
        return grid
    end

    #initialise colours
    int[] initialiseColours() is
        int empty = 0x000000;
        int brown = 0xF4A460;
        int red = 0xFF0000;
        int orange = 0xFFA500;
        int yellow = 0xFFFF00;
        int lime = 0x32CD32;
        int green = 0x00FF00;
        int blue = 0x0000FF;
        int purple = 0x551A8B;
        int pink = 0xFF69B4;
        int[] colours = [brown, red, orange, yellow, lime, green, blue, purple, pink];
        return colours
    end

    int showGrid(int[][] grid) is
        int j = 0;
        while (j < len grid[0]) do
            int i = 0;
            while (i < len grid) do
                print grid[i][j];
                print "\t";
                i += 1
            done;
            println "";
            j += 1
        done;
        return 0
    end

    int drawGridSquare(int[] fb, int x, int y, int colour) is
        #length of each grid square
        #int square_size = 40;

        #margins from top and bottom
        int x_offset = 312;
        int y_offset = 24;

        #struct for the squares to be drawn
        struct Rekt rekt = new Rekt;
        rekt.x = (x * 40) + x_offset;
        rekt.y = (y * 40) + y_offset;
        rekt.width = 40;
        rekt.height = 40;
        rekt.colour = colour;

        call drawRect(fb, rekt);
        return 0
    end

    int drawBlock(int[] fb, int[][] block, int x, int y, int colour) is
        #width and height
        int width = len block;
        int height = len block[0];

        int j = 0;
        while (j < height) do
            int i = 0;
            while (i < width) do
                #draw rectangle
                if (block[i][j] != 0) then
                    call drawGridSquare(fb, x+i, y+j, colour)
                else
                    skip
                fi;
                #increment loop variant
                i += 1
            done;
            j += 1
        done;
        return 0
    end

    int copyBlockToGrid(int[][] block, int[][] grid, int y, int x) is
        # PRE: The block is in a valid position to be written to the grid, and will not overwrrite  anything
        int i = 0;
        while i <  len block do
            int j = 0; 
            while j < len block[0] do
                if (block[i][j] != 0) then 
                    grid[y + i][x + j] = block[i][j]
                else
                    skip
                fi;
                j += 1
            done;
            i += 1
        done;
        return 0
    end

    int isColliding(int[][] block, int[][] grid, int y, int x) is
        int i = 0;
        while i <  len block do
            int j = 0; 
            while j < len block[0] do
                if (block[i][j] != 0)
                    && ((y + i < 0) || (y + i >= len grid) 
                    || (x + j < 0) || (x + j >= len grid[0])
                    || grid[y + i][x + j] != 0)
                then
                    return 1
                else
                    skip
                fi;
                j += 1
            done;
            i += 1
        done;
        return 0
    end 

end