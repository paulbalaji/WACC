begin
    #starting location for all new blocks
    int startX = 4;
    int startY = 0;
    
    #get all the colours
    int[] colours = call initialiseColours();

    #pass in height, width to initilise grid
    int height = 18;
    int width = 10;
    int[][] grid = call initIntArray2D(0, width, height);

    int x = startX;
    int y = startY;

    int colourIndex = 0;

    #get the frame buffer
    int[] fb = get_frame_buffer;

    int[][][][] blocks = call Blocks();

    #initilise first block
    int blockIndex = 0;
    int rotationIndex = 0;
    int[][] block = blocks[blockIndex][rotationIndex];

    call drawBlock(fb, block, x, y, colours[colourIndex]);

    int blah = 12;

    int collision = 0;
    int keepLooping = 1;
    int count = 0;
    int in = 1;
    int horizontal = 1;

    while (keepLooping == 1) do
        in = 0;
        horizontal = 0;

        int count = 0;
        while (count < 10000) do
            in = gpio 27;
            if (in == 1) then
                #horizontal = 1
                #erase square, 0 means black
                call drawBlock(fb, block, x, y, 0);

                #move block horizontally
                #call rotate2(block);

                int savedRotationIndex = rotationIndex;

                #rotate
                rotationIndex += 1;
                if (rotationIndex == 4) then
                    rotationIndex = 0
                else
                    rotationIndex = rotationIndex
                fi;
                
                block = blocks[blockIndex][rotationIndex];

                #if collision don't rotate, else keep rotated shape
                collision = call isColliding(block, grid, x, y);
                if (collision == 1) then
                    rotationIndex = savedRotationIndex;
                    block = blocks[blockIndex][rotationIndex]
                else
                    skip
                fi;

                #draw updated square
                call drawBlock(fb, block, x, y, colours[colourIndex])
            else
                skip
            fi;

            in = gpio 24;
            if (in == 1) then
                horizontal = -1
            else
                skip
            fi;

            collision = call isColliding(block, grid, x + horizontal, y);
            if (horizontal != 0 && collision == 0) then
                #erase square, 0 means black
                call drawBlock(fb, block, x, y, 0);

                #move block horizontally
                x += horizontal;

                #draw updated square
                call drawBlock(fb, block, x, y, colours[colourIndex])
            else
                skip
            fi;

            count += 1
        done;

        collision = call isColliding(block, grid, x, y + 1);

        if (collision == 1) then
            call copyBlockToGrid(block, grid, x, y);

            #get info on what rows need to be shifted down
            int[] rowInfo = call detectRows(grid);

            #while we can still shift down, keep shifting down
            while (rowInfo[0] != 0) do
                call shiftDown(grid, rowInfo);
                rowInfo = call detectRows(grid)
            done;

            colourIndex += 1;
            if (colourIndex == len colours) then
                colourIndex = 0
            else
                colourIndex = colourIndex
            fi;

            blockIndex += 1;
            if (blockIndex == len blocks) then
                blockIndex = 0
            else
                blockIndex = blockIndex
            fi;

            rotationIndex += 1;
            if (rotationIndex == 4) then
                rotationIndex = 0
            else
                rotationIndex = rotationIndex
            fi;
            
            block = blocks[blockIndex][rotationIndex];

            x = startX;
            y = startY;

            call drawBlock(fb, block, x, y, colours[colourIndex]);

            collision = call isColliding(block, grid, x, y);
            if (collision == 1) then keepLooping = 0 else skip fi;
            # Gameover in the true branch of this if
            skip
        else
            #erase square, 0 means black
            call drawBlock(fb, block, x, y, 0);

            #move block down
            y += 1;

            #draw updated square
            call drawBlock(fb, block, x, y, colours[colourIndex])
        fi;
        skip
    done;

    

    while (true) do
        skip
    done;

    skip
end